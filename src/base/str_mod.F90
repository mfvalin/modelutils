!-------------------------------------- LICENCE BEGIN -------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END ---------------------------


!/@
module str_mod
   implicit none
   private
   !@objective Provide string manipulation functions
   !@author Stephane Chamberland, 2011-09
   !@description
   ! Public functions
   public :: str_normalize,str_rm_quotes,str_tab2space,str_toint,str_toreal,str_tobool, str_concat
   ! Public constants
   !
!@/
#include <arch_specific.hf>
#include <rmnlib_basics.hf>
#include <clib_interface_mu.hf>

contains

   !TODO: include str_split fn
   
   !/@*
   subroutine str_normalize(F_str)
      implicit none
      !@objective 
      !@arguments
      character(len=*),intent(inout) :: F_str
      !@author  S. Chamberland, 2012-05
      !*@/
      integer :: istat
      !---------------------------------------------------------------------
      call str_tab2space(F_str)
      F_str = adjustl(F_str)
      istat = clib_tolower(F_str)
      !---------------------------------------------------------------------
      return
   end subroutine str_normalize


   !/@*
   subroutine str_rm_quotes(F_str)
      implicit none
      !@objective Remove leading and trailing quotes/blanks if any
      !@arguments
      character(len=*),intent(inout) :: F_str
      !@author  S. Chamberland, 2010-03
      !*@/
      integer :: ii
      !---------------------------------------------------------------------
      F_str = adjustl(F_str)
      if (F_str(1:1) == "'" .or. F_str(1:1) == '"') then
         ii = len_trim(F_str)
         if (F_str(ii:ii) == F_str(1:1)) then
            F_str(1:1)   = ' '
            F_str(ii:ii) = ' '
            F_str = adjustl(F_str)
         endif
      endif
      !---------------------------------------------------------------------
      return
   end subroutine str_rm_quotes


   !/@*
   subroutine str_tab2space(F_str) !,F_nspaces
      implicit none
      !@objective Replace tab char by space char (so that trim/adjustl work!)
      !@arguments
      character(len=*),intent(inout) :: F_str
      !integer,intent(in) :: F_nspaces !replace tab chars by F_nspaces spaces (not yet implemented - default to 1)
      !@author  S. Chamberland, 2011-04
      !*@/
      integer,parameter :: ASCII_TAB = 9
      integer :: ii
      !---------------------------------------------------------------------
      do ii=1,len_trim(F_str)
         if (iachar(F_str(ii:ii)) == ASCII_TAB) F_str(ii:ii) = ' '
      enddo
      !---------------------------------------------------------------------
      return
   end subroutine str_tab2space


   !/@*
   function str_toint(F_int,F_str_S) result(F_istat)
      implicit none
      integer,intent(out) :: F_int
      character(len=*),intent(in) :: F_str_S
      integer :: F_istat
      !*@/
      integer :: istat
      !---------------------------------------------------------------------
      F_istat = RMN_ERR
      F_int = 0
      read(F_str_S,*,iostat=istat) F_int
      !TODO: prevent from casting a real
      if (istat == 0) F_istat = RMN_OK
      !---------------------------------------------------------------------
      return
   end function str_toint


   !/@*
   function str_toreal(F_real,F_str_S) result(F_istat)
      implicit none
      real,intent(out) :: F_real
      character(len=*),intent(in) :: F_str_S
      integer :: F_istat
      !*@/
      integer :: istat
      !---------------------------------------------------------------------
      F_istat = RMN_ERR
      F_real = 0.
      read(F_str_S,*,iostat=istat) F_real
      if (istat == 0) F_istat = RMN_OK
      !---------------------------------------------------------------------
      return
   end function str_toreal


   !/@*
   function str_tobool(F_bool_L,F_str_S) result(F_istat)
      implicit none
      logical,intent(out) :: F_bool_L
      character(len=*),intent(in) :: F_str_S
      integer :: F_istat
      !*@/
      character(len=32) :: tmp_S
      integer :: istat
      !---------------------------------------------------------------------
      F_istat = RMN_ERR
      F_bool_L = .false.
      tmp_S = F_str_S
      call str_tab2space(tmp_S)
      tmp_S = adjustl(tmp_S)
      istat = clib_tolower(tmp_S)
      if (tmp_S(1:1) == 't' .or. tmp_S(1:2) == '.t') then
         F_bool_L = .true.
         F_istat = RMN_OK
      else if (tmp_S(1:1) == 'f' .or. tmp_S(1:2) == '.f') then
         F_istat = RMN_OK
      endif
      !---------------------------------------------------------------------
      return
   end function str_tobool

   
   !/@*
   subroutine str_concat(F_str_out_S,F_str_array_S,F_sep_S)
      implicit none
      character(len=*),intent(out) :: F_str_out_S
      character(len=*),intent(in)  :: F_str_array_S(:),F_sep_S
      !*@/
      integer :: i
      character(len=512) :: str
      !--------------------------------------------------------------------
      str = F_str_array_S(1)
      call str_tab2space(str)
      F_str_out_S = adjustl(str)
      do i = 2, size(F_str_array_S)
         str = F_str_array_S(i)
         call str_tab2space(str)
         F_str_out_S = trim(F_str_out_S)//F_sep_S//trim(adjustl(str))
      enddo
      !---------------------------------------------------------------------
      return
   end subroutine str_concat

end module str_mod
